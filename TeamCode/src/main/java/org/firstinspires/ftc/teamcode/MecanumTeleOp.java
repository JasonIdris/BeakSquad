package org.firstinspires.ftc.teamcode;import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;import com.qualcomm.robotcore.eventloop.opmode.TeleOp;import com.qualcomm.robotcore.hardware.DcMotor;import com.qualcomm.hardware.logitech.LogitechGamepadF310;import com.qualcomm.robotcore.hardware.DcMotorSimple;import com.qualcomm.robotcore.hardware.Servo;import org.firstinspires.ftc.robotcore.external.ClassFactory;import org.firstinspires.ftc.robotcore.external.matrices.OpenGLMatrix;import org.firstinspires.ftc.robotcore.external.matrices.VectorF;import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;import org.firstinspires.ftc.robotcore.external.navigation.Orientation;import org.firstinspires.ftc.robotcore.external.navigation.RelicRecoveryVuMark;import org.firstinspires.ftc.robotcore.external.navigation.VuMarkInstanceId;import org.firstinspires.ftc.robotcore.external.navigation.VuforiaLocalizer;import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackable;import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackableDefaultListener;import org.firstinspires.ftc.robotcore.external.navigation.VuforiaTrackables;/* Created by connorespenshade on 10/12/17. */@TeleOp(name = "Mecanum TeleOp")public class MecanumTeleOp extends LinearOpMode {    private DcMotor leftFront;    private DcMotor leftBack;    private DcMotor rightFront;    private DcMotor rightBack;    private Servo leftServo;    private Servo rightServo;    private DcMotor liftMotor;    private double DEADZONE = 0.05;    private boolean positive = false;    //VUFORIA    private OpenGLMatrix lastLocation = null;    private VuforiaLocalizer vuforia;    @Override    public void runOpMode() throws InterruptedException {//thhing        leftFront = hardwareMap.dcMotor.get(UniversalConstants.LEFT1NAME);        leftBack = hardwareMap.dcMotor.get(UniversalConstants.LEFT2NAME);        rightFront = hardwareMap.dcMotor.get(UniversalConstants.RIGHT1NAME);        rightBack = hardwareMap.dcMotor.get(UniversalConstants.RIGHT2NAME);        leftServo = hardwareMap.servo.get("ls");        rightServo = hardwareMap.servo.get("rs");        liftMotor = hardwareMap.dcMotor.get("lift");        leftServo.setDirection(Servo.Direction.FORWARD);        leftFront.setDirection(DcMotorSimple.Direction.REVERSE);        rightFront.setDirection(DcMotorSimple.Direction.REVERSE);        double leftServoTargetPos = 0.1;        double rightServoTargetPos = -0.1;        //VUFORIA SETUP        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hardwareMap.appContext.getPackageName());        VuforiaLocalizer.Parameters parameters = new VuforiaLocalizer.Parameters(cameraMonitorViewId);        parameters.vuforiaLicenseKey = "AR3UNn//////AAAAGWw+kvrhWEQ/n8JGCEaAl3lHjtRjVuwoY6pyIsg6Fc1fYaZbyySiQYqRxF29tMJufsu1X91zq+pfrk7qUb49WyQcME7VPLelNQj4I/8QV4nYk/8MqwfVFKqidKnYX2XGxyeLnH2wbOK04Ot9lpDYhBgjs7crF8Lbw/LEv21h54owkSRCsT4SuH0EKIztAlQfhUkwEtZyJ7QGzwtBJ3du06z4MMZcjPX56vPHf6ov4q+4yz2Z3i9RtDGAmIKxl+b31KX50XsZphctCQs5ig16Ho3Anux7E4dQ3/cq2dYGTwzUUiVl4sduiDjrU7O7rlu46X/F4CaTn6Iw7/PKBRe+/jC5iXwcin4U8cDWWxcsVagJ";        parameters.cameraDirection = VuforiaLocalizer.CameraDirection.FRONT;        this.vuforia = ClassFactory.createVuforiaLocalizer(parameters);        VuforiaTrackables relicTrackables = this.vuforia.loadTrackablesFromAsset("RelicVuMark");        VuforiaTrackable relicTemplate = relicTrackables.get(0);        relicTemplate.setName("relicVuMarkTemplate"); // can help in debugging; otherwise not necessary        telemetry.addData(">", "Press Play to start");        telemetry.update();        waitForStart();        relicTrackables.activate();        waitForStart();        while (opModeIsActive()) {            //moveMecanum(gamepad1.right_stick_x, gamepad1.left_stick_y, gamepad1.left_stick_x);            double Ch3 = gamepad1.right_stick_x;            double Ch1 = -gamepad1.left_stick_y;            double Ch4 = gamepad1.left_stick_x;            double FrontLeft = Ch3 + Ch1 + Ch4;            double RearLeft = Ch3 + Ch1 - Ch4;            double RearRight = Ch3 - Ch1 - Ch4;            double FrontRight = Ch3 - Ch1 + Ch4;            //ADD DEADZONE            leftFront.setPower(java.lang.Math.abs(FrontLeft) > DEADZONE ? FrontLeft : 0);            leftBack.setPower(java.lang.Math.abs(RearLeft) > DEADZONE ? RearLeft : 0);            rightFront.setPower(java.lang.Math.abs(FrontRight) > DEADZONE ? FrontRight : 0);            rightBack.setPower(java.lang.Math.abs(RearRight) > DEADZONE ? RearRight : 0);            telemetry.addData("LF Power", leftFront.getPower());            telemetry.addData("LB Power", leftBack.getPower());            telemetry.addData("RF Power", rightFront.getPower());            telemetry.addData("RB Power", rightBack.getPower());/*            if (gamepad2.left_bumper) {                if (leftServo.getPosition() == minServoPos) {                    leftServo.setPosition(maxServoPos);                } else {                    leftServo.setPosition(minServoPos);                }            }            if (gamepad2.right_bumper) {                if (rightServo.getPosition() == maxServoPos) {                    rightServo.setPosition(minServoPos);                } else {                    rightServo.setPosition(maxServoPos);                }            }*/            if (gamepad2.a) {                if (positive) {                     leftServoTargetPos = 0.1;                     rightServoTargetPos = 0.1;                     positive = false;                } else {                     leftServoTargetPos = -0.1;                     rightServoTargetPos = -0.1;                     positive = true;                 }               // leftServoTargetPos = 0.1;               // rightServoTargetPos = 0.1;            }/*            if (gamepad2.b) {                leftServoTargetPos = -0.1;                rightServoTargetPos = -0.1;            }*/            if (gamepad2.left_trigger > 0.1) {                liftMotor.setPower(gamepad2.left_trigger * .3);            } else if (gamepad2.right_trigger > 0.1) {                liftMotor.setPower(-gamepad2.right_trigger * .3);            } else {                liftMotor.setPower(0);            }            leftServo.setPosition(leftServoTargetPos);            rightServo.setPosition(rightServoTargetPos);            telemetry.addData("Left Servo Target Position", leftServoTargetPos);            telemetry.addData("Right Servo Target Position", rightServoTargetPos);            telemetry.addData("Left Servo Actual Position", leftServo.getPosition());            RelicRecoveryVuMark vuMark = RelicRecoveryVuMark.from(relicTemplate);            if (vuMark != RelicRecoveryVuMark.UNKNOWN) {                /* Found an instance of the template. In the actual game, you will probably                 * loop until this condition occurs, then move on to act accordingly depending                 * on which VuMark was visible. */                telemetry.addData("VuMark", "%s visible", vuMark);                /* For fun, we also exhibit the navigational pose. In the Relic Recovery game,                 * it is perhaps unlikely that you will actually need to act on this pose information, but                 * we illustrate it nevertheless, for completeness. */                OpenGLMatrix pose = ((VuforiaTrackableDefaultListener)relicTemplate.getListener()).getPose();                telemetry.addData("Pose", pose);                /* We further illustrate how to decompose the pose into useful rotational and                 * translational components */                if (pose != null) {                    VectorF trans = pose.getTranslation();                    Orientation rot = Orientation.getOrientation(pose, AxesReference.EXTRINSIC, AxesOrder.XYZ, AngleUnit.DEGREES);                    telemetry.addData("VuMark ID", vuMark.name());                    // Extract the X, Y, and Z components of the offset of the target relative to the robot                    double tX = trans.get(0);                    double tY = trans.get(1);                    double tZ = trans.get(2);                    tX = Math.round(tX * 100);                    tX = tX/100;                    tY = Math.round(tY * 100);                    tY = tY/100;                    tZ = Math.round(tZ * 100);                    tZ = tZ/100;                    telemetry.addData("Translation", (Double.toString(tX)) + ", " + (Double.toString(tY)) + ", " + (Double.toString(tZ)));                    // Extract the rotational components of the target relative to the robot                    double rX = rot.firstAngle;                    double rY = rot.secondAngle;                    double rZ = rot.thirdAngle;                    rX = Math.round(rX * 100);                    rX = rX/100;                    rY = Math.round(rY * 100);                    rY = rY/100;                    rZ = Math.round(rZ * 100);                    rZ = rZ/100;                    telemetry.addData("Rotation", (Double.toString(rX)) + ", " + (Double.toString(rY)) + ", " + (Double.toString(rZ)));                }            }            else {                telemetry.addData("VuMark", "not visible");            }            telemetry.update();            idle();        }    }    /*    private void moveMecanum(float Ch1, float Ch3, float Ch4) {        double FrontLeft = Ch3 + Ch1 + Ch4;        double RearLeft = Ch3 + Ch1 - Ch4;        double FrontRight = Ch3 - Ch1 - Ch4;        double RearRight = Ch3 - Ch1 + Ch4;        //ADD DEADZONE`        leftFront.setPower(java.lang.Math.abs(FrontLeft) > DEADZONE ? FrontLeft : 0);        leftBack.setPower(java.lang.Math.abs(RearLeft) > DEADZONE ? RearLeft : 0);        rightFront.setPower(java.lang.Math.abs(FrontRight) > DEADZONE ? FrontRight : 0);        rightBack.setPower(java.lang.Math.abs(RearRight) > DEADZONE ? RearRight : 0);        telemetry.addData("LF Power", leftFront.getPower());        // moar commit    }*/}